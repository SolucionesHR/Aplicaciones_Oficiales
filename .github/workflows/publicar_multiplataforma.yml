name: üåç Publicar App Multiplataforma con Cat√°logo Visual

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: "Nombre de la app"
        required: true
      version:
        description: "Versi√≥n de la app"
        required: true
      private_repo:
        description: "Repositorio privado origen (owner/repo)"
        required: true
        default: "SolucionesHR/mercados_cuba_delivery"
      tag:
        description: "Tag del release privado (ej: v1.0.5)"
        required: true
        default: "v1.0.5"
      assets:
        description: "Lista de archivos en formato: plataforma=archivo (separados por comas, ej: Android=mensajero.apk,Windows=setup.exe)"
        required: true
      gdrive_folder_id:
        description: "URL o ID de almacenamiento externo (Drive/Dropbox/Release - dejar vac√≠o para omitir)"
        required: false

jobs:
  publish-multi:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: üìÇ Checkout repositorio p√∫blico
        uses: actions/checkout@v4
        with:
          lfs: true  # Habilitar Git LFS

      - name: üîß Configurar Git LFS
        run: |
          git lfs install
          git lfs track "*.apk" "*.ipa" "*.zip" "*.exe" "*.dmg"
          git add .gitattributes

      - name: üì• Descargar assets desde release privado
        env:
          GH_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
        run: |
          set -e  # Salir si hay error
          
          IFS=',' read -ra ITEMS <<< "${{ github.event.inputs.assets }}"
          
          for PAIR in "${ITEMS[@]}"; do
            PLATFORM="${PAIR%%=*}"
            ASSET="${PAIR#*=}"
            EXT="${ASSET##*.}"
            DEST="apps/${{ github.event.inputs.app_name }}/${PLATFORM}/${{ github.event.inputs.app_name }}_${PLATFORM}_${{ github.event.inputs.version }}.${EXT}"
            
            echo "üì¶ Descargando $ASSET para $PLATFORM..."
            mkdir -p "$(dirname "$DEST")"
            
            if ! gh release download "${{ github.event.inputs.tag }}" \
              --repo "${{ github.event.inputs.private_repo }}" \
              --pattern "$ASSET" \
              -O "$DEST" \
              --clobber; then
              echo "‚ùå Error al descargar $ASSET"
              exit 1
            fi
            
            # Verificar tama√±o del archivo
            SIZE=$(stat -f%z "$DEST" 2>/dev/null || stat -c%s "$DEST" 2>/dev/null)
            SIZE_MB=$((SIZE / 1024 / 1024))
            echo "üìä Tama√±o de $ASSET: ${SIZE_MB} MB"
            
            if [ $SIZE_MB -gt 95 ]; then
              echo "‚ö†Ô∏è Archivo grande detectado, se usar√° Git LFS autom√°ticamente"
            fi
          done

      - name: ‚òÅÔ∏è Subir a almacenamiento externo (opcional)
        if: ${{ github.event.inputs.gdrive_folder_id != '' }}
        env:
          STORAGE_ENDPOINT: ${{ github.event.inputs.gdrive_folder_id }}
          RCLONE_CONFIG: ${{ secrets.RCLONE_CONFIG }}
        run: |
          set -e
          
          # Opci√≥n 1: Si tienes RCLONE_CONFIG configurado (soporta m√∫ltiples servicios)
          if [ ! -z "$RCLONE_CONFIG" ]; then
            echo "üì¶ Instalando rclone..."
            curl https://rclone.org/install.sh | sudo bash
            
            # Crear config de rclone
            mkdir -p ~/.config/rclone
            echo "$RCLONE_CONFIG" > ~/.config/rclone/rclone.conf
            
            # Subir archivos (funciona con Drive, Dropbox, OneDrive, etc.)
            find apps/${{ github.event.inputs.app_name }} -type f | while read -r FILE; do
              echo "‚òÅÔ∏è Subiendo $FILE..."
              if rclone copy "$FILE" "remote:$STORAGE_ENDPOINT" --progress; then
                echo "‚úÖ Subido: $FILE"
                # Generar link p√∫blico (ajustar seg√∫n servicio)
                FILENAME=$(basename "$FILE")
                echo "STORAGE_LINK_$FILENAME=$STORAGE_ENDPOINT/$FILENAME" >> $GITHUB_ENV
              else
                echo "‚ö†Ô∏è Error al subir $FILE"
              fi
            done
          
          # Opci√≥n 2: Usar GitHub Releases como almacenamiento alternativo
          else
            echo "üì¶ Usando GitHub Releases como almacenamiento..."
            RELEASE_TAG="storage-${{ github.event.inputs.app_name }}-${{ github.event.inputs.version }}"
            
            # Crear release si no existe
            gh release create "$RELEASE_TAG" \
              --title "üì¶ ${{ github.event.inputs.app_name }} v${{ github.event.inputs.version }}" \
              --notes "Archivos de distribuci√≥n" \
              --repo ${{ github.repository }} 2>/dev/null || true
            
            # Subir archivos al release
            find apps/${{ github.event.inputs.app_name }} -type f | while read -r FILE; do
              echo "üì§ Subiendo $FILE a GitHub Release..."
              if gh release upload "$RELEASE_TAG" "$FILE" --clobber --repo ${{ github.repository }}; then
                echo "‚úÖ Subido a Release: $FILE"
                FILENAME=$(basename "$FILE")
                RELEASE_URL="https://github.com/${{ github.repository }}/releases/download/$RELEASE_TAG/$FILENAME"
                echo "STORAGE_LINK_$FILENAME=$RELEASE_URL" >> $GITHUB_ENV
              else
                echo "‚ö†Ô∏è Error al subir $FILE"
              fi
            done
          fi
        env:
          GH_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}

      - name: üñºÔ∏è Generar cat√°logo visual en README
        run: |
          set -e
          
          APP="${{ github.event.inputs.app_name }}"
          VER="${{ github.event.inputs.version }}"
          
          echo "üß© Generando cat√°logo visual..."
          
          # Crear cat√°logo en Markdown
          cat > CATALOG.md << 'CATALOG_START'
          ## üì± Cat√°logo de ${{ github.event.inputs.app_name }}

          | Plataforma | Versi√≥n | Tama√±o | Descargas |
          |------------|---------|--------|-----------|
          CATALOG_START
          
          # Agregar filas por plataforma
          find apps/$APP -type f | sort | while read -r FILE; do
            PLAT=$(echo "$FILE" | cut -d'/' -f3)
            FILENAME=$(basename "$FILE")
            SIZE=$(stat -f%z "$FILE" 2>/dev/null || stat -c%s "$FILE" 2>/dev/null)
            SIZE_MB=$(echo "scale=2; $SIZE / 1024 / 1024" | bc)
            
            # Icono seg√∫n plataforma
            case "$PLAT" in
              Android) ICON="ü§ñ Android";;
              Windows) ICON="üíª Windows";;
              iOS) ICON="üçé iOS";;
              Web) ICON="üåê Web";;
              *) ICON="üì¶ $PLAT";;
            esac
            
            # Link de GitHub
            GITHUB_LINK="[$FILENAME]($FILE)"
            
            # Link de almacenamiento externo si existe
            STORAGE_VAR="STORAGE_LINK_$FILENAME"
            if [ ! -z "${!STORAGE_VAR}" ]; then
              STORAGE_LINK=" ‚Ä¢ [‚òÅÔ∏è Mirror](${!STORAGE_VAR})"
            else
              STORAGE_LINK=""
            fi
            
            echo "| $ICON | v$VER | ${SIZE_MB} MB | $GITHUB_LINK$STORAGE_LINK |" >> CATALOG.md
          done
          
          echo "" >> CATALOG.md
          echo "_√öltima actualizaci√≥n: $(date +'%Y-%m-%d %H:%M UTC')_" >> CATALOG.md
          echo "" >> CATALOG.md
          
          # Actualizar README
          if grep -q "## üì± Cat√°logo de $APP" README.md 2>/dev/null; then
            # Reemplazar secci√≥n existente
            awk -v app="$APP" '
              /## üì± Cat√°logo de / && $0 ~ app {flag=1; next}
              /## / && flag {flag=0}
              !flag
            ' README.md > README.tmp
            cat README.tmp CATALOG.md > README.md
            rm README.tmp
          else
            # Agregar nueva secci√≥n
            cat CATALOG.md >> README.md
          fi
          
          rm CATALOG.md
          echo "‚úÖ Cat√°logo generado correctamente"

      - name: üíæ Commit y push con Git LFS
        run: |
          set -e
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Agregar archivos
          git add .gitattributes
          git add apps/ README.md
          
          # Verificar si hay cambios
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è No hay cambios para commitear"
            exit 0
          fi
          
          # Commit
          git commit -m "üì¶ Publicada ${{ github.event.inputs.app_name }} v${{ github.event.inputs.version }}" \
                     -m "Plataformas actualizadas con cat√°logo visual" \
                     -m "Assets: ${{ github.event.inputs.assets }}"
          
          # Push con LFS
          git lfs push --all origin main
          git push origin main
          
          echo "‚úÖ Cambios publicados correctamente"

      - name: üìã Resumen de publicaci√≥n
        if: always()
        run: |
          echo "### üìä Resumen de Publicaci√≥n" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**App:** ${{ github.event.inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Versi√≥n:** ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag origen:** ${{ github.event.inputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "apps/${{ github.event.inputs.app_name }}" ]; then
            echo "#### üì¶ Archivos publicados:" >> $GITHUB_STEP_SUMMARY
            find apps/${{ github.event.inputs.app_name }} -type f -exec ls -lh {} \; | \
              awk '{print "- " $9 " (" $5 ")"}' >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ github.event.inputs.gdrive_folder_id }}" != "" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Archivos tambi√©n subidos a Google Drive**" >> $GITHUB_STEP_SUMMARY
          fi
