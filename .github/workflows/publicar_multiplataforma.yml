name: ğŸŒ Publicar App Multiplataforma con CatÃ¡logo Visual

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: "Nombre de la app"
        required: true
      version:
        description: "VersiÃ³n de la app"
        required: true
      private_repo:
        description: "Repositorio privado origen (owner/repo)"
        required: true
        default: "SolucionesHR/mercados_cuba_delivery"
      tag:
        description: "Tag del release privado (ej: v1.0.5)"
        required: true
        default: "v1.0.5"
      assets:
        description: "Lista de archivos en formato: plataforma=archivo (separados por comas, ej: Android=mensajero.apk,Windows=setup.exe)"
        required: true

jobs:
  publish-multi:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: ğŸ“‚ Checkout repositorio pÃºblico
        uses: actions/checkout@v4
        with:
          lfs: true  # Habilitar Git LFS

      - name: ğŸ”§ Configurar Git LFS
        run: |
          git lfs install
          git lfs track "*.apk" "*.ipa" "*.zip" "*.exe" "*.dmg"
          git add .gitattributes

      - name: ğŸ“¥ Descargar assets desde release privado
        env:
          GH_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
        run: |
          set -e  # Salir si hay error
          
          IFS=',' read -ra ITEMS <<< "${{ github.event.inputs.assets }}"
          
          for PAIR in "${ITEMS[@]}"; do
            PLATFORM="${PAIR%%=*}"
            ASSET="${PAIR#*=}"
            EXT="${ASSET##*.}"
            DEST="apps/${{ github.event.inputs.app_name }}/${PLATFORM}/${{ github.event.inputs.app_name }}_${PLATFORM}_${{ github.event.inputs.version }}.${EXT}"
            
            echo "ğŸ“¦ Descargando $ASSET para $PLATFORM..."
            mkdir -p "$(dirname "$DEST")"
            
            if ! gh release download "${{ github.event.inputs.tag }}" \
              --repo "${{ github.event.inputs.private_repo }}" \
              --pattern "$ASSET" \
              -O "$DEST" \
              --clobber; then
              echo "âŒ Error al descargar $ASSET"
              exit 1
            fi
            
            # Verificar tamaÃ±o del archivo
            SIZE=$(stat -f%z "$DEST" 2>/dev/null || stat -c%s "$DEST" 2>/dev/null)
            SIZE_MB=$((SIZE / 1024 / 1024))
            echo "ğŸ“Š TamaÃ±o de $ASSET: ${SIZE_MB} MB"
            
            if [ $SIZE_MB -gt 95 ]; then
              echo "âš ï¸ Archivo grande detectado, se usarÃ¡ Git LFS automÃ¡ticamente"
            fi
          done

      - name: ğŸ–¼ï¸ Generar catÃ¡logo visual en README
        run: |
          set -e
          
          APP="${{ github.event.inputs.app_name }}"
          VER="${{ github.event.inputs.version }}"
          
          echo "ğŸ§© Generando catÃ¡logo visual..."
          
          # Crear catÃ¡logo en Markdown
          cat > CATALOG.md << CATALOG_START
          ## ğŸ“± CatÃ¡logo de ${APP}

          | Plataforma | VersiÃ³n | TamaÃ±o | Descargas |
          |------------|---------|--------|-----------|
          CATALOG_START
          
          # Agregar filas por plataforma
          find apps/$APP -type f | sort | while read -r FILE; do
            PLAT=$(echo "$FILE" | cut -d'/' -f3)
            FILENAME=$(basename "$FILE")
            SIZE=$(stat -f%z "$FILE" 2>/dev/null || stat -c%s "$FILE" 2>/dev/null)
            SIZE_MB=$(echo "scale=2; $SIZE / 1024 / 1024" | bc)
            
            # Icono segÃºn plataforma
            case "$PLAT" in
              Android) ICON="ğŸ¤– Android";;
              Windows) ICON="ğŸ’» Windows";;
              iOS) ICON="ğŸ iOS";;
              Web) ICON="ğŸŒ Web";;
              *) ICON="ğŸ“¦ $PLAT";;
            esac
            
            # Link de GitHub
            GITHUB_LINK="[$FILENAME]($FILE)"
            
            # Link de servidor remoto si existe (sanitizar nombre)
            VAR_NAME=$(echo "REMOTE_LINK_$FILENAME" | sed 's/[^a-zA-Z0-9_]/_/g')
            
            # Leer variable de entorno de forma segura
            if env | grep -q "^${VAR_NAME}="; then
              REMOTE_URL=$(env | grep "^${VAR_NAME}=" | cut -d'=' -f2-)
              REMOTE_LINK=" â€¢ [ğŸŒ CDN]($REMOTE_URL)"
            else
              REMOTE_LINK=""
            fi
            
            echo "| $ICON | v$VER | ${SIZE_MB} MB | $GITHUB_LINK$REMOTE_LINK |" >> CATALOG.md
          done
          
          echo "" >> CATALOG.md
          echo "_Ãšltima actualizaciÃ³n: $(date +'%Y-%m-%d %H:%M UTC')_" >> CATALOG.md
          echo "" >> CATALOG.md
          
          # Actualizar README
          if grep -q "## ğŸ“± CatÃ¡logo de $APP" README.md 2>/dev/null; then
            # Reemplazar secciÃ³n existente
            awk -v app="$APP" '
              /## ğŸ“± CatÃ¡logo de / && $0 ~ app {flag=1; next}
              /## / && flag {flag=0}
              !flag
            ' README.md > README.tmp
            cat README.tmp CATALOG.md > README.md
            rm README.tmp
          else
            # Agregar nueva secciÃ³n
            cat CATALOG.md >> README.md
          fi
          
          rm CATALOG.md
          echo "âœ… CatÃ¡logo generado correctamente"

      - name: ğŸ’¾ Commit y push con Git LFS
        run: |
          set -e
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Agregar archivos
          git add .gitattributes
          git add apps/ README.md
          
          # Verificar si hay cambios
          if git diff --staged --quiet; then
            echo "â„¹ï¸ No hay cambios para commitear"
            exit 0
          fi
          
          # Commit
          git commit -m "ğŸ“¦ Publicada ${{ github.event.inputs.app_name }} v${{ github.event.inputs.version }}" \
                     -m "Plataformas actualizadas con catÃ¡logo visual" \
                     -m "Assets: ${{ github.event.inputs.assets }}"
          
          # Push con LFS
          git lfs push --all origin main
          git push origin main
          
          echo "âœ… Cambios publicados correctamente"

      - name: ğŸ“‹ Resumen de publicaciÃ³n
        if: always()
        run: |
          echo "### ğŸ“Š Resumen de PublicaciÃ³n" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**App:** ${{ github.event.inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**VersiÃ³n:** ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag origen:** ${{ github.event.inputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "apps/${{ github.event.inputs.app_name }}" ]; then
            echo "#### ğŸ“¦ Archivos publicados:" >> $GITHUB_STEP_SUMMARY
            find apps/${{ github.event.inputs.app_name }} -type f -exec ls -lh {} \; | \
              awk '{print "- " $9 " (" $5 ")"}' >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ github.event.inputs.remote_upload_path }}" != "" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **Archivos tambiÃ©n disponibles en servidor remoto**" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event.inputs.remote_base_url }}" != "" ]; then
              echo "ğŸ“ **Base URL:** ${{ github.event.inputs.remote_base_url }}" >> $GITHUB_STEP_SUMMARY
            fi
          fi
